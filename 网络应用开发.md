## 套接字

- 是一个标识
- 是一个结构
- 是服务访问点（数据+服务）

### 套接字变量（套接字描述符）

- SOCKET s;
  
    获得一个套接字类型变量，可通过它得到通信服务

- SOCKET s1,s2;

    代表两个不同的通信——标识作用

- SOCKET类型就是整型

    是一个起到标识作用的数值，以提高程序的可读性

### 套接字的操作

- 以套接字为标识，通信服务都是围绕套接字进行的
- 例：一个简单的通信流程，通过调试观察

    ``` C++
    SOCKET s;
    s = SOCKET; //获得套接字资源
    send (s,...); //发送数据
    recv (s,...); //接收数据
    ioctlsocket (s,...);
    setsockopt (s,...);
    //控制套接字工作函数
    ```

## 端口、端点（end point）

### 端口

- 传输层实体用来区分应用进程的通信的标识

### 端口号的分配

- 全局分配（固定分配）
  
    由公认的机构统一分配

- 本地分配（动态分配）

    在本地非知名、未使用的端口中任意选择，每次得到不同的端口号，保证唯一性

### 端点

在网络上唯一确定一个通信应用进程需要：

- 确定网络
- 确定网络上的节点
- 确定节点上的端口
  
确定通信进程 = IP地址（网络号+主机号）+端口号+协议

半相关：破坏了层次的透明性

### 端点地址结构

- 又叫套接字地址
- 端点结构要素：IP地址，端口号
 
    协议类型不在结构中记录

- sockaddr_in结构

    ``` c++
    struct sockaddr_in{
        u_short sin_family; //协议族类型
        u_short sin_port; //端口号
        struct in_addr,sin_addr; //IP地址
        char sin_zero[8]; //保留，没有使用
    }
    ```
- sin_family协议族类型

    Internet使用AF_INET标识，此外，还使用AF_XXX、AP_XXX

- sin_addrIP地址结构

    ``` c++
    struct in_addr{
        union{
            struct{u_char s_b1,s_b2,s_b3,s_b4;} S_un_b;
            struct{u_short s_w1,s_w2;} S_un_w;
            u_long S_addr;
        } S_un;
    }
    
    struct sockaddr_in addr;

    addr.sin_addr
    ```

``` c++
char buf[128];
recv(buf);
sockaddr *sa;
sa = (sockaddr*)buf;
if (sa->family == INET_ADDR){
    sockaddr_in *sai;
    sai = (sockaddr_in*)buf;
    if(sai->addr == MyIP){

    }
}
```